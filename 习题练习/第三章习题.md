# 一.简答题
1.Rust 中的固定宽度数值类型有哪些?这些数值类型的命名规则是什么?
--
Rust 中的固定宽度数值类型包括整型（如 i8, i16, i32, i64, i128 和无符号整型 u8, u16, u32, u64, u128）以及浮点型（f32 和 f64）。命名规则为以前缀（i 表示有符号整数,u 表示无符号整数,f 表示浮点数）和位宽（8, 16, 32, 64, 128）命名。

----------------
2.在 Rust 中,什么是 Box类型?它有何作用?
--
Box是一种智能指针类型,用于在堆上分配数据而不是栈。使用 Box可以创建大小在编译时未知的递归类型或在堆上分配大的数据结构。Box提供了在 Rust 中使用堆内存的简单方式,并帮助实现灵活的内存管理。

----------------
3.String 和 &str它们的主要区别是什么?
--
String是一个动态分配的可变字符串,它存储在堆上,可以改变其大小和内容。String拥有它所分配的内存。适用于需要可变字符串的场景,例如从用户输入中获取数据或构建复杂的字符串操作。
&str是一个不可变的字符串切片,可以指向一个字符串常量或String的一部分。它通常存储在只读内存或栈上。&str是一个借用类型,它只是对内存的一个引用,不能改变其指向的内容。适用于只需要读取字符串而不需要修改的场景。

----------------
4.解释元组和数组在Rust中的主要区别
--
元组可以包含不同类型的值,且每个元素的类型可以不同。元组的长度是固定的,一旦定义就不能改变。元组只允许用常量作为索引,比如 t.4。不能通过写成 t.i 或 t[i] 的形式来获取第 i 个元素。元组主要用于将多个不同类型的值组合在一起,适合函数返回多种类型的值。
数组只能包含相同类型的值,长度也是固定的。所有元素的类型必须相同。元组通过点号和索引访问元素。数组通过方括号和索引访问元素。数组主要用于存储同一类型的多个值,适合需要对一组相同类型的数据进行批量处理的场景。

----------------
5.在Rust中,Box、引用（&）、和裸指针（const或mut）三者在内存管理和所有权方面有什么不同?
--
**内存管理**
Box: 在堆上分配内存,自动管理生命周期。当Box超出作用域时,内存会被自动释放,避免内存泄漏。
引用（& 和 &mut）: 不负责内存管理,仅用于借用现有数据。引用的生命周期依赖于被借用的数据。
裸指针（*const 和 *mut）: 不进行任何内存管理,也不自动释放内存。使用裸指针需要手动管理内存,且不进行安全检查。
**所有权**
Box: 拥有所指向数据的所有权,数据的所有权在Box创建时转移,Box超出作用域时数据会被释放。
引用（& 和 &mut）: 仅借用数据,没有所有权。引用使得原始数据的所有权保持不变,并遵循安全的借用规则。
裸指针（*const 和 *mut）: 没有所有权的概念,仅为指向内存地址的引用,使用时开发者需自行管理数据的所有权和内存

--------------
6.与C和C++不同,Rust几乎不会执行任何隐式的数值转换。如果函数需要 f64 参数,则传入i32型参数是错误的。请举例说明Rust 中如何进行显式的数值转换,并简要说明缺少隐式转换的好处是什么?
--
**显式的数值转换:**
在 Rust 中,可以使用 as 运算符进行显式的数值转换。例如:
将 i16 转换为 i32:let x: i32 = i16_value as i32;
将 i32 转换为 f64:let y: f64 = i32_value as f64;
**缺少隐式转换的好处:**
缺少隐式转换的好处在于,它可以减少因不小心的类型转换而导致的错误和安全漏洞。特别是在表示内存中某些内容的大小时,隐式整数转换可能会导致意外溢出。Rust 要求明确写出数值类型转换,能够提醒开发者注意潜在的问题,从而提高代码的安全性和可读性。

------------------
7.向量 Vec 是一个可调整大小的 T 类型元素的数组,它是在堆上分配的。Vec 由 3 个值组成:指向元素在堆中分配的缓冲区的指针、缓冲区能够存储的元素数量,以及它现在实际包含的数量。其中的容量（capacity）和长度（length）有什么区别?
--
长度（length）:表示向量当前存储的元素数量,可以通过 len() 方法获取。
容量（capacity）:表示向量在不重新分配内存的情况下可以存储的元素的最大数量,可以通过 capacity() 方法获取。

-------------------
8.字符在 Rust 中的存储方式是怎样的?
--
Rust 中的字符用 char 类型表示,存储单个 Unicode 字符,占用 4 个字节的内存空间。

-----------------
9.请简述在 Rust 中随意使用字符串切片可能导致程序崩溃的原因?
--
Rust 中的字符串采用 UTF-8 编码,而字符串切片是通过字节索引进行操作。UTF-8 是一种变长编码方式,不同的字符占用的字节数不同。如果在进行字符串切片时,选择的索引位置没有恰好落在字符的边界上,就会出现错误。

--------------
10.引用、Box 和裸指针在 Rust 中有什么区别?
--
引用是一种安全的指针,不拥有所指向的值的所有权,仅借用值的访问权。Box 是一种智能指针,用于在堆上分配内存并拥有所指向的值的所有权。裸指针是一种低级的指针类型,不提供任何安全保证,使用时需要非常小心,容易导致内存安全问题。

-----------------
13.数组、向量和切片的主要区别是什么?
--
数组是固定长度、相同类型元素的集合,在内存中连续存储。向量是动态大小的数组,可在运行时增长或收缩。切片是对现有数组或向量的引用,不拥有其指向的数据所有权,只指定一个连续的元素范围。

-----------------
14.字符串字面量和 String 类型有哪些不同之处?
--
字符串字面量是硬编码在程序中的字符串常量,存储在程序的二进制文件中,不可变。String 是可动态增长和收缩的字符串类型,存储在堆上,拥有其内容的所有权。

-----------------
15.请简述Rust中Option<&str>类型的用途。
--
Option<&str>类型在Rust中用于表示一个可能为空的字符串切片引用。Option是一个枚举类型,它有两个变体:Some(T)和None。当Option<&str>的值为Some(s)时,表示有一个有效的字符串切片s；当值为None时,表示没有值。这种类型常用于处理可能不存在的字符串值,例如从配置文件中读取字符串时,如果该配置项不存在,则返回一个None值。使用Option类型可以避免空指针异常,并使代码更加安全和易于理解。

-----------------
16.解释Rust中Box\<T>类型的作用。
--
Box\<T>类型在Rust中用于在堆上分配内存,并返回一个指向该内存区域的拥有型指针。Box提供了一种在编译时大小未知或需要在运行时动态分配内存的情况下,将值存储在堆上的方法。当Box\<T>超出其作用域时,它指向的堆内存也会被自动释放,从而避免了内存泄漏。Box常用于实现递归类型（如链表、树等）,或者当结构体中包含一个或多个大型字段时,将这些字段放在Box中以减少栈内存的使用。

-----------------
17.Rust中的Option和Result类型分别用于什么场景?
--
Option类型用于表示一个值可能存在也可能不存在的情况,它有两个变体:Some(T)和None。Result类型用于表示一个操作可能成功也可能失败的情况,它有两个变体:Ok(T)和Err(E)。

------------------
18.Rust 引用有哪两种形式?它们的区别是什么?
--
Rust 引用有两种形式。分别是可变引用&mut T和不可变引用&T。
&T:一个不可变的共享引用。你可以同时拥有多个对给定值的共享引用,但它们是只读的:禁止修改它们所指向的值。
&mut T:一个可变的、独占的引用。你可以读取和修改它指向的值。但是只要该引用还存在,就不能对该值有任何类型的其他引用。
简单来说,在同一时间点,要么只能有一个可变引用,要么只能有多个不可变引用

------------------

19.Rust中的Copy trait有什么作用?
--
Copy trait是一个标记trait,它指示一个类型的值可以被复制而不需要转移其所有权. 这通常用于那些可以安全地复制而不会引起所有权问题的简单数据类型。

-------------------
20.请简述rust中数组、向量、切片的主要区别
--
数组的大小在编译时确定，无法在运行时改变。数组在栈上分配，所有元素连续存储。适合存储数量已知且不变的元素。
向量的大小可以在运行时动态变化，可以随时添加或删除元素。向量在堆上分配，元素也连续存储，但其大小可以动态变化。适合存储数量不固定的元素，提供了丰富的操作方法（如 push, pop, insert 等）
切片是对数组或向量的一部分的引用，不拥有数据本身。它通过引用的方式提供对数据的视图。适合访问部分数据

-------------
21.浮点数的陷阱
--
```
fn main() {
    let abc: (f32, f32, f32) = (0.1, 0.2, 0.3);
	let xyz: (f64, f64, f64) = (0.1, 0.2, 0.3);
	assert!(abc.0 + abc.1 == abc.2);
	assert!(xyz.0 + xyz.1 == xyz.2);  
	//修改此行 使其正常运行。并思考为什么会报错？
}
```
解析：  assert!((xyz.0 + xyz.1 - xyz.2).abs() < 0.001);    
或者使用as进行转换为f32：assert!(xyz.0 as f32 + xyz.1 as f32 == xyz.2 as f32);

对 f32 类型做加法时，0.1 + 0.2 的结果是 3e99999a，0.3 也是 3e99999a，因此 f32 下的 0.1 + 0.2 == 0.3 通过测试。
f64 类型时，结果就不一样了，因为 f64 精度高很多，因此在小数点非常后面发生了一点微小的变化，0.1 + 0.2 以 4 结尾，但是 0.3 以3结尾，这个细微区别导致 f64 下的测试失败了，并且抛出了异常。
f32  f64 上的比较运算实现的是 std::cmp::PartialEq 特征，但是并没有实现 std::cmp::Eq 特征。应避免在浮点数上测试相等性

--------------------------

# 二.选择题
1.在Rust中,以下关于切片（slice）的描述中,哪一项是正确的( )?
--
A. 切片是动态大小的类型,表示对数组的一部分的引用。~
B. 切片在内存中拥有自己的所有权。
C. 切片的长度必须在编译时已知。
D. 切片不能与数组类型一起使用。
正确答案:A. 切片是动态大小的类型,表示对数组的一部分的引用。

---------------
2.运行以下代码时,程序的输出将是什么( )?
--
```
fn main() {
   let integer: i32 = 42;
   let float: f64 = integer;
}
```

A. 42  B. 42.0  C. 编译错误  D. 运行时错误
正确答案: C
在Rust中,整型（如i32）和浮点型（如f64）之间的转换是不允许隐式进行的。这是为了提高代码的安全性和可读性,避免潜在的类型错误。
在代码片段中,let float: f64 = integer; 这一行试图将一个i32类型的变量直接赋值给一个f64类型的变量,但由于Rust不支持这种隐式转换,编译器会在编译时检测到这一点并报告错误。
因此,这段代码会导致编译错误,而不会输出任何值,如42或42.0。这就是选择C. 编译错误的原因。

------------
3.在Rust中,以下哪个类型表示与机器字（32位或64位）一样大的有符号整数?  
--
A. i32  
B. u64  
C. isize  
D. f64
**答案**:C
**解析**:isize是与当前机器字大小相匹配的有符号整数类型,在32位系统上它是32位的,在64位系统上它是64位的。i32始终表示32位有符号整数,u64表示64位无符号整数,f64表示双精度IEEE浮点数。

--------------------
4.Rust中的哪个特性允许你在大多数情况下省略变量或表达式的类型,而Rust编译器仍然能够推断出正确的类型?
--
A. 鸭子类型
B. 类型推断
C. 泛型
D. 生命周期
**答案**:B
**解析**:Rust的类型推断系统非常强大,它允许程序员在大多数情况下省略变量或表达式的类型,编译器会根据上下文自动推断出正确的类型。鸭子类型通常用于描述动态类型语言中的一种特性,即“如果它看起来像鸭子,走路像鸭子,那么它就是鸭子”,而Rust是静态类型语言,不直接支持鸭子类型。泛型用于编写可以处理多种类型的函数或结构体,而生命周期用于管理引用的有效期。

-------------------
# 三.编程题
1.实现一个 Rust 函数 is_even,该函数接收一个 32 位有符号整数作为参数,返回一个布尔值来表示该数是否为偶数。
--
```
fn is_even(n: i32) -> bool {

     n % 2 == 0

   }
```
解析:该函数接收数组引用并使用迭代器求和。Rust 的数组与向量支持 iter 方法,iter().sum()是简洁求和方式

----------------
2.定义一个函数sum_slice,接收一个整数数组切片和两个索引,返回该范围内所有元素的和。
--
```
fn sum_slice(slice: &[i32], start: usize, end: usize) -> i32 {

   // 使用切片从 start 到 end 进行求和

   slice[start..end].iter().sum()

}

fn main() {

   let arr = [1, 2, 3, 4, 5];

   let result = sum_slice(&arr, 1, 4);

println!("范围内的元素之和: {}", result);

}
```
------------------
3.实现一个简单的结构体 Point,用于表示二维平面上的点。添加一个方法 distance_from_origin,计算该点到原点 (0, 0) 的距离
--
```
struct Point {

     x: f64,

     y: f64,

   }

   impl Point {

     fn distance_from_origin(&self) -> f64 {

       (self.x.powi(2) + self.y.powi(2)).sqrt()

     }

   }

   fn main() {

     let p = Point { x: 3.0, y: 4.0 };

     println!("Distance from origin: {}", p.distance_from_origin());

   }
```
解析:Point结构体包含 x和 y 坐标。distance_from_origin 方法利用欧几里得公式计算该点到原点的距离,使用 powi进行平方计算,再用 sqrt 取平方根。

-----------------------
4.填入一行代码,完善函数 calculate_area,接受一个元组 (u32, u32),表示长和宽,返回一个 u32 类型的面积。
--
请完成以下代码:
```
fn calculate_area(dimensions: (u32, u32)) -> u32 {
	dimensions.0 * dimensions.1
}
```
----------------
5.基于已明确写出的类型,Rust 的类型推断会帮你推断出剩下的大部分类型。实际上,对于给定的变量或表达式,通常只会有一种恰当的类型,在这种情况下,Rust允许你省略类型。我将给出一个将数据类型显式表示的代码,请读者将代码改写为隐藏数据类型形式。
--
```
fn build_string_vector() -> Vec<String> {
   let mut v: Vec<String> = Vec::<String>::new();
   v.push(String::from("Hello"));
   v.push(String::from("World"));
   v // 返回向量
}
```
**给出的解答:**
```
fn build_string_vector() -> Vec<_> {
   let mut v = Vec::new(); // 声明一个可变的 Vec,类型由编译器推断
   v.push(String::from("Hello")); // 添加字符串 "Hello"
   v.push(String::from("World")); // 添加字符串 "World"
   v // 返回向量
}
```
-----------------------
6.在Web开发中,模板引擎常常使用字符串替换来动态生成HTML内容。给出一段字符串替换代码,请在下划线出补出缺失代码块:
--
```

use chrono::Local;

fn main() {

let template = "当前时间是:■■";

// 获取当前时间

   let current_time = Local::now().format("%Y-%m-%d %H:%M:%S").to_string();

   let result = template.replace(      ,      );

   println!("{}", result);

}
```

给出的答案:
```
"■■"  ,  &current_time
```
--------------------
7.定义一个包含多个字符的变量,遍历并输出每个字符。
--
```
fn main() {

    let chars = "Hello";

    for c in chars.chars() {

        println!("{}", c);

    }

}
```
--------------------
8.创建一个元组,包含不同类型的数据,提取其中的元素并输出。
--
```
fn main1() {

    let tuple = (1, 'a', true);

    println!("第一个元素:{}", tuple.0);

    println!("第二个元素:{}", tuple.1);

    println!("第三个元素:{}", tuple.2);

}
```
-----------------
9.使用字符串字面量和 String 类型分别创建一个字符串,进行拼接操作并输出结果。
--
```
fn main2() {

    let literal = "Hello";

    let string = String::from("World");

    let result = literal.to_string() + &string;

    println!("拼接结果:{}", result);

}
```
---------------------
10.编写一个Rust函数,该函数接受一个整数数组作为输入,并返回一个包含数组中所有偶数的Vec\<i32>。
--
```
fn main(){

    let numbers = [1, 2, 3, 4, 5, 6];

    let even_numbers = filter_even_numbers(&numbers);

    println!("{:?}", even_numbers); // 输出: [2, 4, 6]

}

fn filter_even_numbers(arr: &[i32]) -> Vec<i32> {

    arr.iter().filter(|&x| x % 2 == 0).cloned().collect()

    }
```
**解析**:  
这个函数filter_even_numbers接受一个整数数组的引用&[i32]作为输入。它使用iter()方法获取数组的迭代器,然后使用filter()方法过滤出所有的偶数（即满足x % 2 == 0的元素）。由于filter()方法返回的是一个引用迭代器,我们使用cloned()方法将其转换为值迭代器,以便可以收集到Vec\<i32>中。最后,使用collect()方法将过滤后的元素收集到一个新的向量中并返回。在main函数中,我们调用这个函数并打印结果。

-----------------------
11.编写一个函数,接受一个char类型的参数,如果它是大写字母,就转换为小写字母并返回,否则返回原字符:
--
```
fn to_lowercase_or_original(c: char) -> char {
    if c.is_ascii_uppercase() {
        c.to_ascii_lowercase()
    } else {
        c
    }
}

fn main() {
    // 测试函数
    let uppercase = 'A';
    let lowercase = 'a';
    let non_alpha = '$';
    
    println!("Original '{}', Lowercase '{}'", uppercase, to_lowercase_or_original(uppercase));

    println!("Original '{}', Lowercase '{}'", lowercase, to_lowercase_or_original(lowercase));

    println!("Original '{}', Lowercase '{}'", non_alpha, to_lowercase_or_original(non_alpha));

}
```

----------------------
12.编写一个函数将&str类型的字符串解析为i32类型的整数,并由Result类型处理可能的解析错误:
--
```
fn parse_to_i32(input: &str) -> Result<i32, &'static str> {

   input.parse::<i32>().map_err(|_| "无法解析为整数")

}

fn main() {

   // 测试函数

   let number_str = "42";

   let result = parse_to_i32(number_str);

   match result {

     Ok(num) => println!("解析后的整数: {}", num),

     Err(e) => println!("Error: {}", e),

   }

   let invalid_str = "not a number";

   let result = parse_to_i32(invalid_str);

   match result {

     Ok(num) => println!("解析后的整数: {}", num),

     Err(e) => println!("Error: {}", e),

   }

}
```
------------------------
13.字符串索引问题，按照提示修改代码：
--

```
fn main() {

    let s1 = String::from("hi,中国");

    let h = s1[0];

// 修改当前行来修复错误,提示: `h` 字符在 UTF-8 格式中只需要 1 个字节来表示

    assert_eq!(h, "h");

    let h1 = &s1[3..5];

// 修改当前行来修复错误，提示: `中` 字符在 UTF-8 格式中需要 3 个字节来表示

    assert_eq!(h1, "中");

}
```

解析：

    let h = &s1[0..1];或者let h = s1.chars().nth(0).unwrap(); // 通过 `chars()` 方法获取第一个字符  

let h1 = &s1[3..6];

--------

# 四.小型项目
1.学生信息管理系统。编写一个简单的 Rust 程序,用于管理学生的信息。每个学生的信息包括:姓名、年龄、学号和成绩。已经给出结构体和主函数,请补充创建学生实例函数和显示学生信息的函数。
--
```
// 定义 Student 结构体
struct Student {
   name: String,
   age: u32,
   student_id: String,
   grade: f32,
}
//创建学生实例函数
//显示学生信息函数
fn main() {
   // 创建学生实例
   let student = create_student("张三", 20, "20230001", 88.5);
   // 显示学生信息
   display_student(&student);

}
```
给出的答案:
```
// 创建学生实例的函数

fn create_student(name: &str, age: u32, student_id: &str, grade: f32) -> Student {

   Student {

     name: name.to_string(),

     age,

     student_id: student_id.to_string(),

     grade,

   }

}

// 显示学生信息的函数

fn display_student(student: &Student) {

   println!("学生姓名: {}", student.name);

   println!("年龄: {}", student.age);

   println!("学号: {}", student.student_id);

   println!("成绩: {}", student.grade);

}
```
-----------------------
2.简单文本编辑器:使用字符串类型和切片等数据类型来实现一个简单的文本编辑器,可以进行文本的输入、编辑、保存等操作。
--
```
use std::io::{self, Write};  // 导入 Write trait
fn main3() {
    let mut text = String::new();
    println!("简单文本编辑器");
    loop {
        print!("> ");
        io::stdout().flush().expect("无法刷新输出");
        let mut input = String::new();
        io::stdin().read_line(&mut input).expect("无法读取输入");
        match handle_command(&input.trim(), &mut text) {
            Ok(()) => continue,
            Err(e) => {
                println!("错误: {}", e);
                break;
            }
        }
    }
}
fn handle_command(command: &str, text: &mut String) -> Result<(), String> {
    match command {
        "quit" => Err("退出程序".to_string()),
        cmd if cmd.starts_with("add ") => {
            text.push_str(&cmd[4..]);
            Ok(())
        }
        "show" => {
            println!("{}", text);
            Ok(())
        }
        _ => {
            println!("未知命令");
            Ok(())
        }
    }
}
```
----------------------
3.编写一个简单的 Rust 程序，实现一个基本的计算器，它可以执行加法、减法、乘法和除法。程序应支持以下功能：
--
1.提示用户输入两个数字（浮点数）。
2.提示用户选择一个操作（加法、减法、乘法或除法）。
3.根据用户的选择执行相应的计算。
4.输出计算结果。
```

use std::io;

fn main() {

    let mut input1 = String::new();
    println!("请输入第一个数字: ");
    io::stdin().read_line(&mut input1).expect("读取失败");
    let num1: f64 = input1.trim().parse().expect("请输入一个有效的数字");
    
    let mut input2 = String::new();
    println!("请输入第二个数字: ");
    io::stdin().read_line(&mut input2).expect("读取失败");
    
    let num2: f64 = input2.trim().parse().expect("请输入一个有效的数字");
    let mut operator = String::new();
    println!("请选择操作 (+, -, *, /): ");
    io::stdin().read_line(&mut operator).expect("读取失败");
    let operator = operator.trim();
    
    let result = match operator {
        "+" => num1 + num2,
        "-" => num1 - num2,
        "*" => num1 * num2,
        "/" => {
            if num2 != 0.0 {
                num1 / num2
            } else {
                println!("错误: 除数不能为零!");
                return;
            }
        },
        _ => {
            println!("无效的操作符!");
            return;
        }
    };
    println!("结果是: {}", result);
}
```
--------------
4.创建一个命令行应用程序，让用户管理一个简单的待办事项列表（Todo List）。用户可以添加、查看、删除任务。
--
```
use std::io::{self, Write};  // 加载 Write 特征

fn clear_screen() {
    print!("{}[2J", 27 as char); // ANSI 转义序列清屏
    io::stdout().flush().unwrap(); // 刷新输出缓冲区
}

fn main() {
    let mut todo_list: Vec<String> = Vec::new();
    loop {
        clear_screen(); // 每次循环开始时清空屏幕
        println!(" *************欢迎使用 Todo List*********    ");
        println!("              1. 添加任务                   ");
        println!("              2. 查看任务                   ");
        println!("              3. 删除任务                   ");
        println!("              4. 退出                       ");
        println!("请选择操作:");
        let mut choice = String::new();
        io::stdin()
            .read_line(&mut choice)
            .expect("无法读取输入");
        let choice: u32 = match choice.trim().parse() {
            Ok(num) => num,
            Err(_) => {
                println!("请输入一个有效的数字！");
                continue;
            }
        };
        match choice {
            1 => {
                println!("请输入任务内容:");
                let mut task = String::new();
                io::stdin().read_line(&mut task).expect("无法读取任务");
                todo_list.push(task.trim().to_string());
                println!("任务添加成功！");
                println!("按下回车键继续...");
                io::stdin().read_line(&mut String::new()).unwrap();
            }

            2 => {
                if todo_list.is_empty() {
                    println!("没有任务！");
                } else {
                    println!("当前任务列表：");
                    for (i, task) in todo_list.iter().enumerate() {
                        println!("{}: {}", i + 1, task);
                    }
                }
                println!("按下回车键继续...");
                io::stdin().read_line(&mut String::new()).unwrap();

            }
            3 => {
                println!("请输入要删除的任务编号:");
                let mut index = String::new();
                io::stdin().read_line(&mut index).expect("无法读取编号");
                let index: usize = match index.trim().parse() {
                    Ok(num) => num,
                    Err(_) => {
                        println!("请输入一个有效的数字！");
                        continue;
                    }
                };
                if index > 0 && index <= todo_list.len() {
                    todo_list.remove(index - 1);
                    println!("任务删除成功！");
                } else {
                    println!("无效的任务编号！");
                }
                println!("按下回车键继续...");
                io::stdin().read_line(&mut String::new()).unwrap();
            }
            4 => {
                println!("退出任务管理系统...");
                break;
            }
            _ => println!("无效选择，请重新输入！"),
        }
    }
}
```

# 五.算法题
1.实现一个简单的冒泡排序算法
--
```
fn sort(arr: &mut [i32]) {

   let len = arr.len();

   for i in 0..len {

     for j in 0..len - 1 - i {

       if arr[j] > arr[j + 1] {

         arr.swap(j, j + 1);

       }

     }

   }

}
```
--------------------------
2.确定一个字符串 s 的所有字符是否全都不同。（使用本章的“|”,”<<”等运算符）限制：0 <= len(s) <= 100 ；  s[i]仅包含小写字母；
--
```
pub fn is_unique(astr: String) -> bool {
         let mut bitmask: u32 = 0;     // 用于记录字符的出现情况
         for ch in astr.chars() {
            let bit = ch as u32 - 'a' as u32;  // 将字符转化为对应的索引
            if bitmask & (1 << bit) != 0 {  // 如果该位已经是 1，说明字符重复
                return false;
            }
            bitmask |= 1 << bit;  // 将对应的位设置为 1
        }
        true
    }
```

复杂度分析：
**时间复杂度**：O(n)，其中 n 是字符串的长度。每个字符都被处理一次，u32 的位操作是常数时间操作。
**空间复杂度**：O(1)，我们只用了一个 u32 来记录字符的状态，所以空间复杂度是常数

--------------------